<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CPython/Objects/obmalloc.c -- small object memory allocation Â· iMuxin's Blog</title><meta name="description" content="CPython/Objects/obmalloc.c -- small object memory allocation - imuxin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.slicloud.com:38876/atom.xml" title="iMuxin's Blog"></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="/blog/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link">ARTICLES</a></li><li class="nav-list-item"><a href="/blog/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/imuxin/blog" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/blog/2019/09/29/contribute/" target="_self" class="nav-list-link">CONTRIBUTE</a></li><li class="nav-list-item"><a href="/blog/2019/09/15/About/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">CPython/Objects/obmalloc.c -- small object memory allocation</h1><div class="post-info">imuxin @Nov 14, 2019</div><div class="post-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#About-memory"><span class="toc-text">About memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Questions"><span class="toc-text">Questions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dive-into-source-code"><span class="toc-text">Dive into source code</span></a></li></ol></div><div class="post-content"><p>Here is the abstract of the post.</p>
<a id="more"></a>

<h2 id="About-memory"><a href="#About-memory" class="headerlink" title="About memory"></a>About memory</h2><h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><ol>
<li><p>What is size of long unsigned int</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lx\n"</span>, (<span class="keyword">intptr_t</span>)((<span class="keyword">size_t</span>)<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, (<span class="keyword">intptr_t</span>)((<span class="keyword">size_t</span>)<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, (<span class="keyword">intptr_t</span>)(((<span class="keyword">size_t</span>)<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">PyObject_Malloc(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see PyMem_RawMalloc() */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; (<span class="keyword">size_t</span>)PY_SSIZE_T_MAX)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> _PyObject.<span class="built_in">malloc</span>(_PyObject.ctx, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>call heri</li>
</ol>
<p>pymalloc_alloc -&gt; </p>
<h2 id="Dive-into-source-code"><a href="#Dive-into-source-code" class="headerlink" title="Dive into source code"></a>Dive into source code</h2><ol>
<li>variables and structs</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The system's VMM page size can be obtained on most unices with a</span></span><br><span class="line"><span class="comment"> * getpagesize() call or deduced from various header files. To make</span></span><br><span class="line"><span class="comment"> * things simpler, we assume that it is 4K, which is OK for most systems.</span></span><br><span class="line"><span class="comment"> * It is probably better if this is the native page size, but it doesn't</span></span><br><span class="line"><span class="comment"> * have to be.  In theory, if SYSTEM_PAGE_SIZE is larger than the native page</span></span><br><span class="line"><span class="comment"> * size, then `POOL_ADDR(p)-&gt;arenaindex' could rarely cause a segmentation</span></span><br><span class="line"><span class="comment"> * violation fault.  4K is apparently OK for all the platforms that python</span></span><br><span class="line"><span class="comment"> * currently targets.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_PAGE_SIZE        (4 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_PAGE_SIZE_MASK   (SYSTEM_PAGE_SIZE - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Size of the pools used for small blocks. Should be a power of 2,</span></span><br><span class="line"><span class="comment"> * between 1K and SYSTEM_PAGE_SIZE, that is: 1k, 2k, 4k.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_SIZE               SYSTEM_PAGE_SIZE        <span class="comment">/* must be 2^N */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_SIZE_MASK          SYSTEM_PAGE_SIZE_MASK</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_POOLS_IN_ARENA  (ARENA_SIZE / POOL_SIZE)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* When you say memory, my mind reasons in terms of (pointers to) blocks */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint8_t</span> block;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pool for small blocks. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123; block *_padding;</span><br><span class="line">            uint count; &#125; ref;          <span class="comment">/* number of allocated blocks    */</span></span><br><span class="line">    block *freeblock;                   <span class="comment">/* pool's free list head         */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">nextpool</span>;</span>       <span class="comment">/* next pool of this size class  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">prevpool</span>;</span>       <span class="comment">/* previous pool       ""        */</span></span><br><span class="line">    uint arenaindex;                    <span class="comment">/* index into arenas of base adr */</span></span><br><span class="line">    uint szidx;                         <span class="comment">/* block size class index        */</span></span><br><span class="line">    uint nextoffset;                    <span class="comment">/* bytes to virgin block         */</span></span><br><span class="line">    uint maxnextoffset;                 <span class="comment">/* largest valid nextoffset      */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* Record keeping for arenas. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span> &#123;</span></span><br><span class="line">    <span class="comment">/* The address of the arena, as returned by malloc.  Note that 0</span></span><br><span class="line"><span class="comment">     * will never be returned by a successful malloc, and is used</span></span><br><span class="line"><span class="comment">     * here to mark an arena_object that doesn't correspond to an</span></span><br><span class="line"><span class="comment">     * allocated arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pool-aligned pointer to the next pool to be carved off. */</span></span><br><span class="line">    block* pool_address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The number of available pools in the arena:  free pools + never-</span></span><br><span class="line"><span class="comment">     * allocated pools.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    uint nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The total number of pools in the arena, whether or not available. */</span></span><br><span class="line">    uint ntotalpools;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Singly-linked list of available pools. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span>* <span class="title">freepools</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Whenever this arena_object is not associated with an allocated</span></span><br><span class="line"><span class="comment">     * arena, the nextarena member is used to link all unassociated</span></span><br><span class="line"><span class="comment">     * arena_objects in the singly-linked `unused_arena_objects` list.</span></span><br><span class="line"><span class="comment">     * The prevarena member is unused in this case.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When this arena_object is associated with an allocated arena</span></span><br><span class="line"><span class="comment">     * with at least one available pool, both members are used in the</span></span><br><span class="line"><span class="comment">     * doubly-linked `usable_arenas` list, which is maintained in</span></span><br><span class="line"><span class="comment">     * increasing order of `nfreepools` values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Else this arena_object is associated with an allocated arena</span></span><br><span class="line"><span class="comment">     * all of whose pools are in use.  `nextarena` and `prevarena`</span></span><br><span class="line"><span class="comment">     * are both meaningless in this case.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">nextarena</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">prevarena</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Array of objects used to track chunks of memory (arenas). */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenas</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="comment">/* Number of slots currently allocated in the `arenas` vector. */</span></span><br><span class="line"><span class="keyword">static</span> uint maxarenas = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The head of the singly-linked, NULL-terminated list of available</span></span><br><span class="line"><span class="comment"> * arena_objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">unused_arena_objects</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The head of the doubly-linked, NULL-terminated at each end, list of</span></span><br><span class="line"><span class="comment"> * arena_objects associated with arenas that have pools available.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">usable_arenas</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* nfp2lasta[nfp] is the last arena in usable_arenas with nfp free pools */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">nfp2lasta</span>[<span class="title">MAX_POOLS_IN_ARENA</span> + 1] = &#123;</span> <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* How many arena_objects do we initially allocate?</span></span><br><span class="line"><span class="comment"> * 16 = can allocate 16 arenas = 16 * ARENA_SIZE = 4MB before growing the</span></span><br><span class="line"><span class="comment"> * `arenas` vector.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIAL_ARENA_OBJECTS 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Number of arenas allocated that haven't been free()'d. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> narenas_currently_allocated = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Total number of times malloc() called to allocate an arena. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> ntimes_arena_allocated = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* High water mark (max value ever seen) for narenas_currently_allocated. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> narenas_highwater = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>functions</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Allocate a new arena.  If we run out of memory, return NULL.  Else</span></span><br><span class="line"><span class="comment"> * allocate a new arena, and return the address of an arena_object</span></span><br><span class="line"><span class="comment"> * describing the new arena.  It's expected that the caller will set</span></span><br><span class="line"><span class="comment"> * `usable_arenas` to the return value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>*</span></span><br><span class="line"><span class="class"><span class="title">new_arena</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenaobj</span>;</span></span><br><span class="line">    uint excess;        <span class="comment">/* number of bytes above pool alignment */</span></span><br><span class="line">    <span class="keyword">void</span> *address;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> debug_stats = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug_stats == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *opt = Py_GETENV(<span class="string">"PYTHONMALLOCSTATS"</span>);</span><br><span class="line">        debug_stats = (opt != <span class="literal">NULL</span> &amp;&amp; *opt != <span class="string">'\0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (debug_stats)</span><br><span class="line">        _PyObject_DebugMallocStats(<span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unused_arena_objects == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        uint i;</span><br><span class="line">        uint numarenas;</span><br><span class="line">        <span class="keyword">size_t</span> nbytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Double the number of arena objects on each allocation.</span></span><br><span class="line"><span class="comment">         * Note that it's possible for `numarenas` to overflow.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        numarenas = maxarenas ? maxarenas &lt;&lt; <span class="number">1</span> : INITIAL_ARENA_OBJECTS;</span><br><span class="line">        <span class="keyword">if</span> (numarenas &lt;= maxarenas)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;                <span class="comment">/* overflow */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SIZEOF_SIZE_T &lt;= SIZEOF_INT</span></span><br><span class="line">        <span class="keyword">if</span> (numarenas &gt; SIZE_MAX / <span class="keyword">sizeof</span>(*arenas))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;                <span class="comment">/* overflow */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        nbytes = numarenas * <span class="keyword">sizeof</span>(*arenas);</span><br><span class="line">        arenaobj = (struct arena_object *)PyMem_RawRealloc(arenas, nbytes);</span><br><span class="line">        <span class="keyword">if</span> (arenaobj == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        arenas = arenaobj;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We might need to fix pointers that were copied.  However,</span></span><br><span class="line"><span class="comment">         * new_arena only gets called when all the pages in the</span></span><br><span class="line"><span class="comment">         * previous arenas are full.  Thus, there are *no* pointers</span></span><br><span class="line"><span class="comment">         * into the old array. Thus, we don't have to worry about</span></span><br><span class="line"><span class="comment">         * invalid pointers.  Just to be sure, some asserts:</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        assert(usable_arenas == <span class="literal">NULL</span>);</span><br><span class="line">        assert(unused_arena_objects == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Put the new arenas on the unused_arena_objects list. */</span></span><br><span class="line">        <span class="keyword">for</span> (i = maxarenas; i &lt; numarenas; ++i) &#123;</span><br><span class="line">            arenas[i].address = <span class="number">0</span>;              <span class="comment">/* mark as unassociated */</span></span><br><span class="line">            arenas[i].nextarena = i &lt; numarenas - <span class="number">1</span> ?</span><br><span class="line">                                   &amp;arenas[i+<span class="number">1</span>] : <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update globals. */</span></span><br><span class="line">        unused_arena_objects = &amp;arenas[maxarenas];</span><br><span class="line">        maxarenas = numarenas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Take the next available arena object off the head of the list. */</span></span><br><span class="line">    assert(unused_arena_objects != <span class="literal">NULL</span>);</span><br><span class="line">    arenaobj = unused_arena_objects;</span><br><span class="line">    unused_arena_objects = arenaobj-&gt;nextarena;</span><br><span class="line">    assert(arenaobj-&gt;address == <span class="number">0</span>);</span><br><span class="line">    address = _PyObject_Arena.alloc(_PyObject_Arena.ctx, ARENA_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* The allocation failed: return NULL after putting the</span></span><br><span class="line"><span class="comment">         * arenaobj back.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        arenaobj-&gt;nextarena = unused_arena_objects;</span><br><span class="line">        unused_arena_objects = arenaobj;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arenaobj-&gt;address = (<span class="keyword">uintptr_t</span>)address;</span><br><span class="line"></span><br><span class="line">    ++narenas_currently_allocated;</span><br><span class="line">    ++ntimes_arena_allocated;</span><br><span class="line">    <span class="keyword">if</span> (narenas_currently_allocated &gt; narenas_highwater)</span><br><span class="line">        narenas_highwater = narenas_currently_allocated;</span><br><span class="line">    arenaobj-&gt;freepools = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* pool_address &lt;- first pool-aligned address in the arena</span></span><br><span class="line"><span class="comment">       nfreepools &lt;- number of whole pools that fit after alignment */</span></span><br><span class="line">    arenaobj-&gt;pool_address = (block*)arenaobj-&gt;address;</span><br><span class="line">    arenaobj-&gt;nfreepools = MAX_POOLS_IN_ARENA;</span><br><span class="line">    excess = (uint)(arenaobj-&gt;address &amp; POOL_SIZE_MASK);</span><br><span class="line">    <span class="keyword">if</span> (excess != <span class="number">0</span>) &#123;</span><br><span class="line">        --arenaobj-&gt;nfreepools;</span><br><span class="line">        arenaobj-&gt;pool_address += POOL_SIZE - excess;</span><br><span class="line">    &#125;</span><br><span class="line">    arenaobj-&gt;ntotalpools = arenaobj-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arenaobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* called when pymalloc_alloc can not allocate a block from usedpool.</span></span><br><span class="line"><span class="comment"> * This function takes new pool and allocate a block from it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>*</span><br><span class="line">allocate_from_new_pool(uint size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* There isn't a pool of the right size class immediately</span></span><br><span class="line"><span class="comment">     * available:  use a free pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(usable_arenas == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="comment">/* No arena has a free pool:  allocate a new arena. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WITH_MEMORY_LIMITS</span></span><br><span class="line">        <span class="keyword">if</span> (narenas_currently_allocated &gt;= MAX_ARENAS) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        usable_arenas = new_arena();</span><br><span class="line">        <span class="keyword">if</span> (usable_arenas == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        usable_arenas-&gt;nextarena = usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">        assert(nfp2lasta[usable_arenas-&gt;nfreepools] == <span class="literal">NULL</span>);</span><br><span class="line">        nfp2lasta[usable_arenas-&gt;nfreepools] = usable_arenas;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(usable_arenas-&gt;address != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This arena already had the smallest nfreepools value, so decreasing</span></span><br><span class="line"><span class="comment">     * nfreepools doesn't change that, and we don't need to rearrange the</span></span><br><span class="line"><span class="comment">     * usable_arenas list.  However, if the arena becomes wholly allocated,</span></span><br><span class="line"><span class="comment">     * we need to remove its arena_object from usable_arenas.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    assert(usable_arenas-&gt;nfreepools &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nfp2lasta[usable_arenas-&gt;nfreepools] == usable_arenas) &#123;</span><br><span class="line">        <span class="comment">/* It's the last of this size, so there won't be any. */</span></span><br><span class="line">        nfp2lasta[usable_arenas-&gt;nfreepools] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If any free pools will remain, it will be the new smallest. */</span></span><br><span class="line">    <span class="keyword">if</span> (usable_arenas-&gt;nfreepools &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        assert(nfp2lasta[usable_arenas-&gt;nfreepools - <span class="number">1</span>] == <span class="literal">NULL</span>);</span><br><span class="line">        nfp2lasta[usable_arenas-&gt;nfreepools - <span class="number">1</span>] = usable_arenas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to get a cached free pool. */</span></span><br><span class="line">    poolp pool = usable_arenas-&gt;freepools;</span><br><span class="line">    <span class="keyword">if</span> (LIKELY(pool != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="comment">/* Unlink from cached pools. */</span></span><br><span class="line">        usable_arenas-&gt;freepools = pool-&gt;nextpool;</span><br><span class="line">        usable_arenas-&gt;nfreepools--;</span><br><span class="line">        <span class="keyword">if</span> (UNLIKELY(usable_arenas-&gt;nfreepools == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">/* Wholly allocated:  remove. */</span></span><br><span class="line">            assert(usable_arenas-&gt;freepools == <span class="literal">NULL</span>);</span><br><span class="line">            assert(usable_arenas-&gt;nextarena == <span class="literal">NULL</span> ||</span><br><span class="line">                   usable_arenas-&gt;nextarena-&gt;prevarena ==</span><br><span class="line">                   usable_arenas);</span><br><span class="line">            usable_arenas = usable_arenas-&gt;nextarena;</span><br><span class="line">            <span class="keyword">if</span> (usable_arenas != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">                assert(usable_arenas-&gt;address != <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* nfreepools &gt; 0:  it must be that freepools</span></span><br><span class="line"><span class="comment">             * isn't NULL, or that we haven't yet carved</span></span><br><span class="line"><span class="comment">             * off all the arena's pools for the first</span></span><br><span class="line"><span class="comment">             * time.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            assert(usable_arenas-&gt;freepools != <span class="literal">NULL</span> ||</span><br><span class="line">                   usable_arenas-&gt;pool_address &lt;=</span><br><span class="line">                   (block*)usable_arenas-&gt;address +</span><br><span class="line">                       ARENA_SIZE - POOL_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Carve off a new pool. */</span></span><br><span class="line">        assert(usable_arenas-&gt;nfreepools &gt; <span class="number">0</span>);</span><br><span class="line">        assert(usable_arenas-&gt;freepools == <span class="literal">NULL</span>);</span><br><span class="line">        pool = (poolp)usable_arenas-&gt;pool_address;</span><br><span class="line">        assert((block*)pool &lt;= (block*)usable_arenas-&gt;address +</span><br><span class="line">                                 ARENA_SIZE - POOL_SIZE);</span><br><span class="line">        pool-&gt;arenaindex = (uint)(usable_arenas - arenas);</span><br><span class="line">        assert(&amp;arenas[pool-&gt;arenaindex] == usable_arenas);</span><br><span class="line">        pool-&gt;szidx = DUMMY_SIZE_IDX;</span><br><span class="line">        usable_arenas-&gt;pool_address += POOL_SIZE;</span><br><span class="line">        --usable_arenas-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usable_arenas-&gt;nfreepools == <span class="number">0</span>) &#123;</span><br><span class="line">            assert(usable_arenas-&gt;nextarena == <span class="literal">NULL</span> ||</span><br><span class="line">                   usable_arenas-&gt;nextarena-&gt;prevarena ==</span><br><span class="line">                   usable_arenas);</span><br><span class="line">            <span class="comment">/* Unlink the arena:  it is completely allocated. */</span></span><br><span class="line">            usable_arenas = usable_arenas-&gt;nextarena;</span><br><span class="line">            <span class="keyword">if</span> (usable_arenas != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">                assert(usable_arenas-&gt;address != <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Frontlink to used pools. */</span></span><br><span class="line">    block *bp;</span><br><span class="line">    poolp next = usedpools[size + size]; <span class="comment">/* == prev */</span></span><br><span class="line">    pool-&gt;nextpool = next;</span><br><span class="line">    pool-&gt;prevpool = next;</span><br><span class="line">    next-&gt;nextpool = pool;</span><br><span class="line">    next-&gt;prevpool = pool;</span><br><span class="line">    pool-&gt;ref.count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;szidx == size) &#123;</span><br><span class="line">        <span class="comment">/* Luckily, this pool last contained blocks</span></span><br><span class="line"><span class="comment">         * of the same size class, so its header</span></span><br><span class="line"><span class="comment">         * and free list are already initialized.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        bp = pool-&gt;freeblock;</span><br><span class="line">        assert(bp != <span class="literal">NULL</span>);</span><br><span class="line">        pool-&gt;freeblock = *(block **)bp;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Initialize the pool header, set up the free list to</span></span><br><span class="line"><span class="comment">     * contain just the second block, and return the first</span></span><br><span class="line"><span class="comment">     * block.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pool-&gt;szidx = size;</span><br><span class="line">    size = INDEX2SIZE(size);</span><br><span class="line">    bp = (block *)pool + POOL_OVERHEAD;</span><br><span class="line">    pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    pool-&gt;maxnextoffset = POOL_SIZE - size;</span><br><span class="line">    pool-&gt;freeblock = bp + size;</span><br><span class="line">    *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pymalloc allocator</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Return a pointer to newly allocated memory if pymalloc allocated memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Return NULL if pymalloc failed to allocate the memory block: on bigger</span></span><br><span class="line"><span class="comment">   requests, on error in the code below (as a last chance to serve the request)</span></span><br><span class="line"><span class="comment">   or when the max memory limit has been reached.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span>*</span><br><span class="line">pymalloc_alloc(<span class="keyword">void</span> *ctx, <span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WITH_VALGRIND</span></span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(running_on_valgrind == <span class="number">-1</span>)) &#123;</span><br><span class="line">        running_on_valgrind = RUNNING_ON_VALGRIND;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(running_on_valgrind)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(nbytes == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(nbytes &gt; SMALL_REQUEST_THRESHOLD)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint size = (uint)(nbytes - <span class="number">1</span>) &gt;&gt; ALIGNMENT_SHIFT;</span><br><span class="line">    poolp pool = usedpools[size + size];</span><br><span class="line">    block *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LIKELY(pool != pool-&gt;nextpool)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * There is a used pool for this size class.</span></span><br><span class="line"><span class="comment">         * Pick up the head block of its free list.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ++pool-&gt;ref.count;</span><br><span class="line">        bp = pool-&gt;freeblock;</span><br><span class="line">        assert(bp != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UNLIKELY((pool-&gt;freeblock = *(block **)bp) == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="comment">// Reached the end of the free list, try to extend it.</span></span><br><span class="line">            pymalloc_pool_extend(pool, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* There isn't a pool of the right size class immediately</span></span><br><span class="line"><span class="comment">         * available:  use a free pool.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        bp = allocate_from_new_pool(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_PyObject_Malloc(<span class="keyword">void</span> *ctx, <span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* ptr = pymalloc_alloc(ctx, nbytes);</span><br><span class="line">    <span class="keyword">if</span> (LIKELY(ptr != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = PyMem_RawMalloc(nbytes);</span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        raw_allocated_blocks++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div></main><footer><div class="paginator"><a href="/blog/2019/11/07/Web-IDE/" class="next">NEXT</a></div><div class="copyright"><p>Â© 2019 - 2020 <a href="http://www.slicloud.com:38876">imuxin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script><script src="/blog/js/post.js"></script></body></html>